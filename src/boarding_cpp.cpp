#include <Rcpp.h>
#include "boarding_cpp.h"
#include "sir_cpp.h"
#include "logdensities.h"
#include "sampling.h"
using namespace Rcpp;
using namespace std;

/* 
 * Given population size N, there are (N+1) * N / 2 low-dimensional states (s,i) possible. 
 * we create a matrix that stores all these states. 
 */
// [[Rcpp::export]]
IntegerMatrix boarding_all_lowdim_states(const int N){
  int nlowdim_states = (N + 2) * (N + 1) / 2;
  IntegerMatrix allstates(nlowdim_states, 2);
  int istate = 0;
  for(int scnt = N; scnt>=0 ; scnt--){
    for(int icnt = N - scnt; icnt >= 0; icnt--){
      allstates(istate,0) = scnt;
      allstates(istate,1) = icnt;
      // Rcout << "state # " <<  istate <<" s = " << scnt << "i= " << icnt << "\n";
      istate++;
      }
    }
  return allstates;
  }

/*
 * given population size, lowdim summary (s,i)
 * return the index of this state in the matrix generated by boarding_all_lowdim_states
 */
// [[Rcpp::export]]
int boarding_lowdim2index(const int N, const int scnt, const int icnt){
  return int (N - scnt) * (N - scnt + 1) / 2  + N - scnt - icnt; 
  }

/*
 * 
 */

void boarding_bif_update(NumericMatrix logpolicy, 
                         const IntegerVector & y, 
                         const IntegerMatrix & all_lowdim_states,
                         const double & lambda, 
                         const double & gamma, 
                         const int & N,
                         const double &c){
  }


/*
 this function is equivalent to running create_fbar_matrix and sir_bif_create_cpp
 current implementation assumes network_type == "full";
 */

// [[Rcpp::export]]
NumericMatrix boarding_bif_create_cpp(const IntegerVector & y,
                                      const IntegerMatrix & all_lowdim_states,
                                      const double & lambda, 
                                      const double & gamma, 
                                      const double & rho,
                                      const int & N,
                                      const double & c){
  // current implementation assumes network_type == "full"
  int days = y.size();
  // Rcout << "observation length = " <<  days <<"\n";
  int nlowdim_states = (N + 2) * (N + 1) / 2;
  
  // initialize the policy vector to -Inf
  NumericMatrix logpolicy(nlowdim_states,  days);
  std::fill(logpolicy.begin(), logpolicy.end(), R_NegInf);
  
  // start the recursion from t = days - 1. 
  int t = days - 1;
  for(int ilowdim = all_lowdim_states.nrow() - 1; ilowdim >= 0; ilowdim--){
    logpolicy(ilowdim, t) =  R::dbinom(y[t], all_lowdim_states(ilowdim, 1), rho, true);
    }
  
  int snow, inow, snext, inext;
  int supper, slower, iupper, ilower;
  double currlsum, ladd, currlmax;
  // run the recursion backwards
  for(int t = days - 2; t >= 0 ; t--){
    for(int ilowdimnow = all_lowdim_states.nrow() - 1; ilowdimnow >= 0; ilowdimnow--){ // for every state
      snow = all_lowdim_states(ilowdimnow, 0);
      inow = all_lowdim_states(ilowdimnow, 1);
      currlsum = R_NegInf;
      // consider a subset of states that can be reaches from (snow, inow);
      slower = snow * (1 - inow * lambda / N) - c * sqrt(N) / 2;
      supper = snow * (1 - inow * lambda / N) + c * sqrt(N) / 2 + 0.5;
      slower = max(0, slower);
      supper = min(snow, supper);
      for(int snext = supper; snext >= slower; snext--){
        ilower = inow + snow - snext - inow * gamma - c * sqrt(N) / 2;
        iupper = inow + snow - snext - inow * gamma + c * sqrt(N) / 2 + 0.5;
        ilower = max(snow - snext, ilower);
        iupper = min(inow + snow - snext, iupper);
        for(int inext = iupper; inext >= ilower; inext--){
          // snext and inext defines a future state
          ladd = sir_logfbar(snow, inow, snext, inext, lambda, gamma, N) + logpolicy(boarding_lowdim2index(N, snext, inext), t+1);
          if(!Rcpp::traits::is_infinite<REALSXP>(ladd)){
            currlmax = max(currlsum, ladd);
            currlsum = log(exp(currlsum - currlmax) + exp(ladd - currlmax)) + currlmax;
            }
          }
        }
        logpolicy(ilowdimnow, t) = currlsum +  R::dbinom(y[t], inow, rho, true);
      }
    }
  return logpolicy;
} 
